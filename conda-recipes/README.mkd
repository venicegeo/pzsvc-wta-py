# Using Miniconda to get to PCF

## The problem

There are many dependent C++ libraries and shared objects that aren't installed
in our Jenkins or PCF instances. We need to bring these in ourselves. Pip within PCF
is buggy and misses ordering dependencies.

## The solution

Use [Miniconda](https://conda.io/miniconda.html) to package all of the Python and Libraries we need

## How?

Miniconda works in a similar way as pip and virtualenv. It packages all of the dependecies in a
non-system location and you can deploy your app. [Conda Recipes](https://github.com/conda/conda-recipes) are built using _yaml_ and shell scripts.

## Get Started

### Vagrant and Virtualbox

The simplest way is to use [Vagrant](https://www.vagrantup.com/) and a Virtual Machine.

Install Vagrant and [Virtualbox](https://www.virtualbox.org/) if you don't have it already.

The following _Vagrantfile_ will get you up and going:

```
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(2) do |config|

  # A clean slate CentOS 7 Machine for experimenting and testing
  config.vm.define "condabld", autostart: false do |condabld|
    condabld.vm.box = "bhosmer/centos7-minimal"
    condabld.vm.hostname = "condabld.rbtcloud.dev"
    condabld.vm.network "private_network", ip: "192.168.33.90"
  end
config.vm.synced_folder ".", "/vagrant", type: "nfs"
  config.vm.provider "virtualbox" do |vb|
     vb.memory = "2048"
  end
end
```

Start the machine:

`$ vagrant up condabld`

After it is loaded, `$ vagrant ssh condabld`

### Development tools (gcc etc.)

Install the development tools:
```
# sudo yum -y install epel-release
# sudo yum -y update
# sudo yum -y install zlib-devel gcc gcc-c++ autogen libtool make autoconf automake freetype-devel SDL-devel python-devel
```
Now you can [install](https://conda.io/docs/install/quick.html) _miniconda_ within the virtual-machine (version 2, Python 2.7, please).

### Serving a local Conda repo

Conda expects repos to be available via http and currently doesn't support a direct filesystem.

I installed NGINX (yum install) and just served the repo files on the machine I use to build from.

After building, your repo will be located in `~/miniconda2/conda-bld/`. Here's the `/etc/nginx/conf.d/anacond.conf` file:


```
server {
    listen 80;
    server_name 192.168.33.90;
    root /home/vagrant/miniconda2/conda-bld/;
    location / {
      autoindex on;
    }
}
```

Also, modify the `/etc/nginx/nginx.conf` to run NGINX as `vagrant`:

```
...
# For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

#user nginx;
user vagrant;
...
```

***CAUTION Only for Local Development***
If you know how to configure your firewall to allow external http traffic, 
configure it to do so. Otherwise, for this local development environment, you can 
simply disable it:

`# systemctl disable firewalld`

`# systemctl stop firewalld`

Selinux is enabled by default. You can either disable it, [but you shouldn't](https://stopdisablingselinux.com/), `# setenforce 0`, or add the `httpd_can_network_connect`:

`# setsebool httpd_can_network_connect on`

`# setsebool httpd_enable_homedirs on`

### Conda Build

We use potrace provided by th bioconda channel and gdal which comes from the conda-forge channel. You can add these channels so that conda will find them when building with: 

`$ conda config --add channels conda-forge`

`$ conda config --add channels bioconda`

All that's left now is to install [conda build](https://github.com/conda/conda-build). `$ conda install conda-build`


## Building Packages

The `path:` points to the `vendor` directory within the repo. Download the source
and extract the contents to the directory specified in `path:`.

You can find the [conda recipes](https://github.com/venicegeo/pzsvc-ndwi-py/tree/pipeline-refactor/conda-recipes) in the [pzsv-ndwi-py](https://github.com/venicegeo/pzsvc-ndwi-py) repo.

For example, the `pypotrace/` directory contains a `build.sh` and a `meta.yaml`. These describe how to build the package.

The [_meta.yaml_](https://github.com/conda/conda-docs/blob/master/docs/source/building/meta-yaml.rst#id11) file has lots of options that might suit your needs.

Some packages don't exist in the Anaconda.org repo. Those are the ones that we
have to build with conda.

Currently, you'll have to build the following packages yourself:

    - agg
    - pypotrace
    - gippy

In each respective directory, the `meta.yaml` specifies the location of the 
source. This source isn't stored in the repo, but you can find the download links
within the `meta.yaml`.

For example, `pypotrace`:

```
...
source:
  # https://pypi.python.org/packages/28/6f/59ebf9fa50553426d28c0aec6d0690e84cca3841edd10276afaaedb8d02b/pypotrace-0.1.3.tar.gz 
  path: ../vendor/pypotrace
...
```

You can now build the conda package with `$ conda build pypotrace/`. The package is then automatically added to `~/miniconda2/conda-bld/`

## Testing your packages locally

You can now use miniconda to test your package locally.

Using an `environment.yaml` file:

```
name: bfalg
channels:
  - http://192.168.33.90
  - bioconda
  - conda-forge
  - defaults
  - NESII
dependencies:
  - python=2.7.13
  - pip
  - cython
  - pypotrace=0.1.3
  - potrace=1.11
  - libagg=2.5.0
  - fiona=1.7.4
  - gdal=2.1.3
  - gippy
```

Place this in `~/pzsvc/environment.yaml` and `$ conda env create -f pzsvc/environment.yaml`

To clean the environment for another run `$ source deactivate` and then
 `$ conda env remove -n bfalg`.

After conda creates the environment, you can invoke your local interpreter with:

`$ source activate bfalg`

```
$ python
>>> import numpy
>>> import potrace
>>> import gippy
```

